### 论文上的解法的变形

- 论文中的方法的核心是保证$\frac{B+rn}{s_i}\leq m_0\leq \frac{2B-1+rn}{s_i}$成立，然后启发式的增长$s_i$，因为M的取值空间的大小是$\frac{B-1}{s_i}$，所以$s_i$必须与N同个级别的大小。所以$s_i$要指数增长
- 不过，$s_i$也不可以一下子变大很多，因为上面不等式中$\frac{as_i-2B+1}{n}\leq r\leq \frac{bs_i-B}{n}$，r的取值空间是$\frac{(b-a)s_i+B-1}{n}$。而对于每个r，都有一个相应的$m_0$的取值空间。所以如果$s_i$指数增长，就可能会有指数个取值空间——当然，通过一些优化措施可以使得这个数目大大降低。
- 所以，$s_i$的增长策略就变得很重要。我没有推导出对于任意$n$，要如何设置$s_i$的增长策略。不过对于题目的n，可以调到一组参数，使之对数复杂度

### 另一种解法

- 因为`n=0x400...`（共1011 bit），所以如果第1009bit（从0开始算起）的oracle返回1，那么最高两个bit就是`01`
- 利用这个特性，使得该oracle变成了两bit oracle，然后，使用[Tokyo Westerns/MMA CTF 2016 – Pinhole Attack](http://mslc.ctf.su/wp/tokyo-westernsmma-ctf-2016-pinhole-attack-crypto-500/)类似的方法，就可以对数复杂度解出来。
- 这个方法的核心是，利用每个d得到的区间的交叉，使得区间数保持稳定，然后d指数增长。其中，如果$d_n=2*d_{n-1}$，那么区间数是没有变化的——因为第二个循环得到的有效区间的边界是与第一个循环得到的对齐的，然后大小变为一半，这就使得原来的有效区间的一半变为现在的有效区间，另一半变为无效的区间。而如果$d_n<2*d_{n-1}$，那么区间数就更加ok了。并且，只要$d_n=k*d_{n-1}(k>1)$，那么d就可以指数增长，那么$N/d$就可以指数变小，那么这个算法就是对数复杂度，exciting！

